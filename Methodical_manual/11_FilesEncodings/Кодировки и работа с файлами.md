После сложных объектных тем рассмотрим более простую практическую тему.

Перед разговором о теме лекции поговорит о _контекстном менеджере_ — виде классов в Python, для которого из-за его популярности сделали отдельных формат обработки.

В классических паттернах разработки есть блок типа «finally», который работает независимо от всех исключений итд. 

Класс контекстного менеджера требует протокола: `__enter__` для входа в контекст и `__exit__` для выхода

```python
>>> class CM:  
...     def __init__(self, val = None):  
...         self.val = val  
...    
...     def __enter__(self):  
...         print("ENTER")  
...    
...     def __exit__(self, *args):  
...         print("EXIT",*args)  
...    
...    
>>>    
>>> with CM(123) as cm:  
...     print("ASKLFASF")  
... with CM(123) as cm:  
...     print("BBB")  
...     raise RuntimeError("QQ!")  
...     print("CCC")  
...        
ENTER  
ASKLFASF  
EXIT None None None  
ENTER  
BBB  
EXIT <class 'RuntimeError'> QQ! <traceback object at 0x7fe2c8144180>  
Traceback (most recent call last):  
 File "<python-input-2>", line 5, in <module>  
   raise RuntimeError("QQ!")  
RuntimeError: QQ!  
>>>
```

```python
>>> with open("o1") as file:  
...     print(file.read())  
...        
[root@first ~]# ip -d link show br0 | grep root  
   bridge forward_delay 1500 hello_time 200 max_age 2000 ageing_time 30000 stp_state 0 priority 32768  
vlan_filtering 0 vlan_protocol 802.1Q bridge_id 8000.8:0:27:f:58:56 designated_root 8000.8:0:27:f:58:56  
root_port 0 root_path_cost 0 topology_change 0 topology_change_detected 0 hello_timer    0.00 tcn_time  
r    0.00 topology_change_timer    0.00 gc_timer   72.73 fdb_n_learned 0 fdb_max_learned 0 vlan_default  
_pvid 1 vlan_stats_enabled 0 vlan_stats_per_port 0 group_fwd_mask 0 group_address 01:80:c2:00:00:00 mca  
st_snooping 1 no_linklocal_learn 0 mcast_vlan_snooping 0 mst_enabled 0 mcast_router 1 mcast_query_use_i  
faddr 0 mcast_querier 0 mcast_hash_elasticity 16 mcast_hash_max 4096 mcast_last_member_count 2 mcast_st  
artup_query_count 2 mcast_last_member_interval 100 mcast_membership_interval 26000 mcast_querier_interv  
al 25500 mcast_query_interval 12500 mcast_query_response_interval 1000 mcast_startup_query_interval 312  
5 mcast_stats_enabled 0 mcast_igmp_version 2 mcast_mld_version 1 nf_call_iptables 0 nf_call_ip6tables 0  
nf_call_arptables 0 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 tso_max_size 655  
36 tso_max_segs 65535 gro_max_size 65536 gso_ipv4_max_size 65536 gro_ipv4_max_size 65536  
  
>>>
```

---
---

Байтовая структура bytes

```python
>>> s = 'ЙЦЗТМщзфтм 12'  
>>> b = b'QAWlkbav'  
>>> type(s), type(b)  
(<class 'str'>, <class 'bytes'>)  
>>> b  
b'QAWlkbav'
```

```python
>>> # Пайтон хитрый и один из лучших по работе со строками. Но если мы хотим СИ-подобную байтовую «стр\  
оку», это про bytes  
>>>    
>>> b.find(b'we')  
-1  
>>> b.find(b'av')  
6  
>>> b'we' + 'we'  
Traceback (most recent call last):  
 File "<python-input-11>", line 1, in <module>  
   b'we' + 'we'  
   ~~~~~~^~~~~~  
TypeError: can't concat str to bytes  
>>>
```

```python
>>> b[1:-1]  
b'AWlkba'  
>>> b[3]  
108  
>>> type(b[3])  
<class 'int'>  
>>>
```


Есть ещё более специфический тип данных — bytearray. Настоящий массив байт. Изменяемый! И  быстро работает, это реально просто массив

```python
>>> bytearray(b)  
bytearray(b'QAWlkbav')  
>>> ba = bytearray([1, 2, 3])  
>>> ba  
bytearray(b'\x01\x02\x03')  
>>> ba[1] = 100  
>>> ba  
bytearray(b'\x01d\x03')  
>>> list(ba)  
[1, 100, 3]  
>>>
```

---
---

1. Мы очень часто говорим, что строки состоят из «символов». ==Понятие «символа» слишком _многозначно_ и нередко представляет собой нечто противоположное знаку: символ маркирует целый культурно-ассоциативный корпус, для каждого человека — а тем более в разных культурах — разный.== А то, что мы хотим называть символами, это знаки.


---
---

Экскурс. Так сложилось, что когда-то строки состояли из байтов. Однако когда появилась необходимость кодировать разные языки, встала проблема. Решили зафиксировать 0-127 для латиницы, общей для всех, а 128-255 оставили на общее использование. То, как будут интерпретироваться эти нефиксированные блоки, определяет _кодировка_ — соответствие некоторого числа конкретному символу.

UNICODE — общий универсальный способ каталогизации.
Самая большая и популярная кодировка — UTF. Вообще говоря, тоже семейство.

В UTF используется многобайтовая кодировка:

```
0·······            — 1 байт / 7 бит
110·····   10······ — 2 байта / 11 битов
1110···· 2×10······ — 3 байта / 16 битов
11110··· 3×10······ — 4 байта / 21 бит
```

Исторически первыми были однобайтовые кодировки. И с ними было плохо: для разных языков наросло много кодировок на одно и то же. По однобайтовой кодировке мы не можем понять изначальность кодировки

```python
>>> s = "Вопрос:"  
>>> s.encode("CP1251")  
b'\xc2\xee\xef\xf0\xee\xf1:'  
>>> res = s.encode("CP1251")  
>>> res  
b'\xc2\xee\xef\xf0\xee\xf1:'  
>>> len(res)  
7  
>>> res.decode("KOI8-R")  
'бНОПНЯ:'  
>>>
```

```python
>>> s.encode("UTF-8")  
b'\xd0\x92\xd0\xbe\xd0\xbf\xd1\x80\xd0\xbe\xd1\x81:'  
>>> res = s.encode("UTF-8")  
>>> type(res)  
<class 'bytes'>  
>>> list(res)  
[208, 146, 208, 190, 208, 191, 209, 128, 208, 190, 209, 129, 58]  
>>> for i in res:  
...     print(f'{i:08b}')  
...        
11010000  
10010010  
11010000  
10111110  
11010000  
10111111  
11010001  
10000000  
11010000  
10111110  
11010001  
10000001  
00111010  
>>>
```

В действительности, в Python все символы хранятся в виде двубайтных величин — питоний юникод

```python
>>> import sys  
>>> sys.getsizeof("qwe")  
44  
>>> sys.getsizeof("qwer")  
45  
>>> sys.getsizeof("qwerЮ")  
68  
>>> sys.getsizeof("qwerЮЮ")  
70  
>>>
```

```python
>>> # А некоторые вообще не раскодируются одно через другое  
>>>    
>>> s  
'Вопрос:'  
>>> s.encode("CP1251").decode("latin3")  
Traceback (most recent call last):  
 File "<python-input-40>", line 1, in <module>  
   s.encode("CP1251").decode("latin3")  
   ~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^  
 File "/usr/lib/python3.13/encodings/iso8859_3.py", line 15, in decode  
   return codecs.charmap_decode(input,errors,decoding_table)  
          ~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  
UnicodeDecodeError: 'charmap' codec can't decode byte 0xf0 in position 3: character maps to <undefined>  
decoding with 'latin3' codec failed  
>>>
```

---
---

Интересная тема — именование через Unicode

```python
>>> import unicodedata  
>>> unicodedata.lookup("MIDDLE DOT")  
'·'  
>>> unicodedata.name('«')  
'LEFT-POINTING DOUBLE ANGLE QUOTATION MARK'  
>>> '\u2102'  
'ℂ'  
>>> '\N{FOR ALL}'  
'∀'  
>>>
```

---

## Файлы

```python
>>> with open('o') as file:  
...     print(file.read())  
...        
Пн 17 ноя 2025 17:18:57 MSK  
  
>>> # Питон различает байтовый и текстовый потоки. Байтовый идёт по базе, текстовый encode-decode-ится  
>>> шьзщке дщсфду  
 File "<python-input-2>", line 1  
   шьзщке дщсфду  
          ^^^^^^  
SyntaxError: invalid syntax  
>>> import locale  
>>> locale.getlocale()  
('en_US', 'UTF-8')  
>>>
```

---
---

```python
>>> with open('o') as file:  
...     print(file.read())  
...        
    Ноябрь 2025       
Пн Вт Ср Чт Пт Сб Вс  
               1  2  
3  4  5  6  7  8  9  
10 11 12 13 14 15 16  
17 18 19 20 21 22 23  
24 25 26 27 28 29 30  
                      
  
>>> with open('o') as file:  
...     for line in file:  
...         print(line)  
...            
    Ноябрь 2025       
  
Пн Вт Ср Чт Пт Сб Вс  
  
               1  2  
  
3  4  5  6  7  8  9  
  
10 11 12 13 14 15 16  
  
17 18 19 20 21 22 23  
  
24 25 26 27 28 29 30  
  
                      
  
>>> with open('o') as file:  
...     for line in file:  
...         print(line, end='')  
...            
    Ноябрь 2025       
Пн Вт Ср Чт Пт Сб Вс  
               1  2  
3  4  5  6  7  8  9  
10 11 12 13 14 15 16  
17 18 19 20 21 22 23  
24 25 26 27 28 29 30  
                      
>>>
```

Теперь откроем, как бинарь

```python
>>> with open('o', 'rb') as file:  
...     print(file.read())  
...        
b'     \xd0\x9d\xd0\xbe\xd1\x8f\xd0\xb1\xd1\x80\xd1\x8c 2025    \n\xd0\x9f\xd0\xbd \xd0\x92\xd1\x82 \xd  
0\xa1\xd1\x80 \xd0\xa7\xd1\x82 \xd0\x9f\xd1\x82 \xd0\xa1\xd0\xb1 \xd0\x92\xd1\x81\n                1  2  
\n 3  4  5  6  7  8  9\n10 11 12 13 14 15 16\n17 18 19 20 21 22 23\n24 25 26 27 28 29 30\n               
      \n'  
>>>
```

---

```python
>>> file = open('o')  
>>> file.readline()  
'     Ноябрь 2025    \n'  
>>> file.readline()  
'Пн Вт Ср Чт Пт Сб Вс\n'  
>>> file.readline()  
'                1  2\n'  
>>> file.readline()  
' 3  4  5  6  7  8  9\n'  
>>> file.readline()  
'10 11 12 13 14 15 16\n'  
>>> file.readline()  
'17 18 19 20 21 22 23\n'  
>>> file.readline()  
'24 25 26 27 28 29 30\n'  
>>> file.readline()  
'                    \n'  
>>> file.readline()  
''  
>>> file.readline()  
''  
>>> file.readline()  
''  
>>>
```

---

seek для движения указателя ввода-вывода

```python
>>> file = open('o', 'rb')  
>>> file.seek(30)  
30  
>>> file.readline()  
b'\xbd \xd0\x92\xd1\x82 \xd0\xa1\xd1\x80 \xd0\xa7\xd1\x82 \xd0\x9f\xd1\x82 \xd0\xa1\xd0\xb1 \xd0\x92\xd  
1\x81\n'  
>>> file.seek(60)  
60  
>>> file.readline()  
b'\x81\n'  
>>> file.seek(70)  
70  
>>> file.readline()  
b'        1  2\n'  
>>>
```

---

Pathlib — современная библиотека для работы с файлами

---

Для работы в обычной жизни используются потоки ввода, вывода и ошибок. Строковые форматы — sys.stdin\out\err. А для байтовой версии добавляем `.buffer` 

```python
>>> import sys  
>>> print("aa", file=sys.stderr)  
aa  
>>> sys.stdout.buffer.write(b'QWRETY')  
QWRETY6  
>>> w = sys.stdout.buffer.write(b'QWRETY')  
QWRETY>>>    
>>> w  
6  
>>>
```

Есть как бы файл-поток StringIO

```python
>>> import io  
>>> file = io.StringIO("sadasd\nqweqwe\zxv\n")  
<python-input-32>:1: SyntaxWarning: invalid escape sequence '\z'  
>>> file = io.StringIO("sadasd\nqweqwe\nzxv\n")  
>>> file.readline()  
'sadasd\n'  
>>> file.readline()  
'qweqwe\n'  
>>> file.readline()  
'zxv\n'  
>>> file.readline()  
''  
>>>
```

---
---
Сериализация объектов Python — модуль Pickle

```python
>>> import pickle  
>>> pickle.dumps(123)  
b'\x80\x04K{.'  
>>> pickle.dumps([1, 2, 3, 4, 5])  
b'\x80\x04\x95\x0f\x00\x00\x00\x00\x00\x00\x00]\x94(K\x01K\x02K\x03K\x04K\x05e.'  
>>>
```

Протоколы сериализации:

```python
>>> res = [123, 234.234, "WERWERWER", (1, 2, 3)]  
>>> pickle.dumps(res, 0)  
b'(lp0\nI123\naF234.234\naVWERWERWER\np1\na(I1\nI2\nI3\ntp2\na.'  
>>>
```

```python
>>> with open('o', 'wb') as file:  
...     pickle.dump(res, file)  
...        
>>>    
   ~  hexdump -C 0                                                                ✔  23m 52s     
hexdump: 0: No such file or directory  
hexdump: all input file arguments failed  
   ~  hexdump -C o                                                                          1 ✘    
00000000  80 04 95 24 00 00 00 00  00 00 00 5d 94 28 4b 7b  |...$.......].(K{|  
00000010  47 40 6d 47 7c ed 91 68  73 8c 09 57 45 52 57 45  |G@mG|..hs..WERWE|  
00000020  52 57 45 52 94 4b 01 4b  02 4b 03 87 94 65 2e     |RWER.K.K.K...e.|  
0000002f  
   ~  python3.13                                                                              ✔    
Python 3.13.7 (main, Aug 15 2025, 12:34:02) [GCC 15.2.1 20250813] on linux  
Type "help", "copyright", "credits" or "license" for more information.  
>>> import pickle  
>>> with open('o', 'rb') as file:  
...     res = pickle.load(file)  
...        
>>> res  
[123, 234.234, 'WERWERWER', (1, 2, 3)]  
>>>
```

---
---

Мы разобрались, как работать с массивами целых, а массивы структур? Как читать данные с заданными размерами блоков? Для этого есть специальный модуль struct

Птичий язык для задания, но таков путь

```python
   ~  # делаем 4 символа строка + число и перевод строки                                      ✔    
zsh: bad pattern: #  
   ~  cat > file                                                                            1 ✘    
qqq     
qw  
   ~  hexdump -C file                                                                 ✔  14s     
00000000  71 71 71 0a 71 77 0a                              |qqq.qw.|  
00000007  
   ~  python3.13                                                                              ✔    
Python 3.13.7 (main, Aug 15 2025, 12:34:02) [GCC 15.2.1 20250813] on linux  
Type "help", "copyright", "credits" or "license" for more information.  
>>> import struct  
>>> FM = '4sHc'  
>>> FMT = '4sHc'  
>>> with open('file', 'rb') as f:  
...     data = f.read()  
...        
>>> data  
b'qqq\nqw\n'  
>>> struct.unpack(FMT, data)  
(b'qqq\n', 30577, b'\n')  
>>> struct.pack(FMT, b'qaqa', 200, b'\0')  
b'qaqa\xc8\x00\x00'  
>>>
```

Сюда же отдельным приколом идёт порядок байт: LE и BE

---
---

Файл как база данных — модуль `dbm`

