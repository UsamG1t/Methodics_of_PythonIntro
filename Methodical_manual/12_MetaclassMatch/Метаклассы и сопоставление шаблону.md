Очень хочется подтянуть аннотации, ибо они — встроенный элемент питона. Но тут много не получится.

Вообще в статическом питоне (MyPy) они играют главную роль, а тут играют роль подсказок 

---

Сначала про не-метаклассы

например, разлилчие дескрипторов в одном объекте с помощью set_name

Далее — `__init_subclass__` для доп.параметров при создании класса-наследника

```python
>>> class Isub:  
...     def __init_subclass__(self, *args, **kwargs):  
...         print(args, kwargs)  
...         super().__init_subclass__(*args, **kwargs)  
...            
>>> class C(Isub):  
...     pass  
...        
() {}  
```

Мы можем передавать именные параметры из производного всем своим родителям для какого-то апгрейда

```python
>>> class Isub:  
...     def __init_subclass__(self, **kwargs):  
...         print(kwargs)  
...         super().__init_subclass__()  
...            
>>> class C(Isub, parameters="QQ"):  
...     pass  
...        
{'parameters': 'QQ'}  
>>>
```

Этот метод по умолчанию является классовым, но никак не помечается (`@classmethod`)

---
---

"Если вы задумались, нужны ли вам метаклассы или не нужны, они вам не нужны" ⓒ

Метаклассы. 

Зайдём с мысли: с помощью чего можно сделать класс? Явно его описать, вызвать функцию, сделать декоратор (тоже функция, но красивая), преобразовать один декоратор к классу и получить другой класс (при этом есть две вещи: создать новый или пропатчить текущий)

А ещё класс может быть потомком другого. Просто породить производный или тем самым встраиванием `__init_subclass__` его улучшать

Представим, что у нас есть некий конструктор класса, который создаёт их. Создавая через него классы, мы получаем чистенький класс, хотя по интроспекции там 100500 вещей применено для создания.

Можно придумать 100500 мыслей, зачем, но (см. замечание номер 0)

---

Вспомним функцию type, которая, вообще говоря, класс

```python
>>> type  
<class 'type'>  
>>> type(type)  
<class 'type'>  
>>>    
>>> C = type('C', (), {'A': 123})  
>>> C  
<class '__main__.C'>  
>>>
```

Что будет, если мы создадим производный от type класс? Получим другой конструктор классов:

```python
>>> class overtype(type):  
...     def __init__(self, *args, **kwargs):  
...         print(args, kwargs)  
...         super().__init__(*args, **kwargs)  
...            
>>> C = overtype('C', (), {'A': 123})  
('C', (), {'A': 123}) {}  
>>>    
>>> class C(metaclass=overtype):  
...     A = 100500  
...        
('C', (), {'__module__': '__main__', '__qualname__': 'C', '__firstlineno__': 1, 'A': 100500, '__static_  
attributes__': ()}) {}  
>>>
```

Осталось понять, какие спец.методы есть у метаклассов.

---

```python
from pprint import pprint
class ctype(type):
    @classmethod
    def __prepare__(metacls, name, bases, **kwds):
        pprint(("prepare", name, bases, kwds))
        return super().__prepare__(name, bases, **kwds)
    def __new__(metacls, name, parents, ns, **kwds):
        pprint(("new", metacls, name, parents, ns, kwds))
        return super().__new__(metacls, name, parents, ns)
    def __init__(cls, name, parents, ns, **kwds):
        pprint(("init", cls, parents, ns, kwds))
        return super().__init__(name, parents, ns)
    def __call__(cls, *args, **kwargs):
        pprint(("call", cls, args, kwargs))
        return super().__call__(*args, **kwargs)
class C(int, metaclass=ctype, parameter="See me"):
    field = 42
print("Create an instance:")
c = C("100500", base=16)
print(c, c % 256, type(c), type(c % 256))
```

 + `__prepare__` срабатывает самым первым и создаёт пространство имён будущего класса
 + `__new__` создаёт экземпляр метакласса, т.е. сам класс
 + `__init__` вызывается в момент описания нашего класса и срабатывает как инициализатор для класса
 + `__call__` описывает привычное действие создания экземпляра самого класса

Важно помнить, что:
 + `__prepare__` это классовый метод
 + `__new__` это статический метод!

```python
>>> from pprint import pprint  
...    
... class ctype(type):  
...     @classmethod  
...     def __prepare__(metacls, name, bases, **kwds):  
...         pprint(("prepare", name, bases, kwds))  
...         return super().__prepare__(name, bases, **kwds)  
...    
...     def __new__(metacls, name, parents, ns, **kwds):  
...         pprint(("new", metacls, name, parents, ns, kwds))  
...         return super().__new__(metacls, name, parents, ns)  
...    
...     def __init__(cls, name, parents, ns, **kwds):  
...         pprint(("init", cls, parents, ns, kwds))  
...         return super().__init__(name, parents, ns)  
...    
...     def __call__(cls, *args, **kwargs):  
...         pprint(("call", cls, args, kwargs))  
...         return super().__call__(*args, **kwargs)  
...    
... class C(int, metaclass=ctype, parameter="See me"):  
...     field = 42  
...    
... print("Create an instance:")  
... c = C("100500", base=16)  
... print(c, c % 256, type(c), type(c % 256))  
...    
('prepare', 'C', (<class 'int'>,), {'parameter': 'See me'})  
('new',  
<class '__main__.ctype'>,  
'C',  
(<class 'int'>,),  
{'__firstlineno__': 21,  
 '__module__': '__main__',  
 '__qualname__': 'C',  
 '__static_attributes__': (),  
 'field': 42},  
{'parameter': 'See me'})  
('init',  
<class '__main__.C'>,  
(<class 'int'>,),  
{'__firstlineno__': 21,  
 '__module__': '__main__',  
 '__qualname__': 'C',  
 '__static_attributes__': (),  
 'field': 42},  
{'parameter': 'See me'})  
Create an instance:  
('call', <class '__main__.C'>, ('100500',), {'base': 16})  
1049856 0 <class '__main__.C'> <class 'int'>  
>>>
```

И тут снова проблема проксирования (type(c % 256))

И чем отличается описание через `metaclass=` от `type(…)`. Тут **не** вызывается `__prepare__`

---
---

Посмотрим немного примеров. Первый — ненаследуемый класс

```python
>>> class Final(type):  
...     def __new__(metacls, cls, parents, namespace):  
...         for parent in parents:  
...             if isinstance(parent, Final):  
...                 raise TypeError(f"No inheritancefrom {parent}")  
...         return super().__new__(metacls, cls, parents, namespace)  
...            
>>> class E(metaclass=Final):  
...     a = 1  
...        
>>> class D(E):  
...     pass  
...        
Traceback (most recent call last):  
 File "<python-input-26>", line 1, in <module>  
   class D(E):  
       pass  
 File "<python-input-24>", line 5, in __new__  
   raise TypeError(f"No inheritancefrom {parent}")  
TypeError: No inheritancefrom <class '__main__.E'>  
>>>
```

Ещё примерчик — Синглтон, класс с единственным экземпляром

```python
>>> class Singleton(type):  
...     _instance = None  
...     def __call__(cls, *args, **kwargs):  
...         if cls._instance is None:  
...             cls._instance = super().__call__(*args, **kwargs)  
...         return cls._instance  
...            
>>> class A(metaclass=Singleton):  
...     B = 100500  
...        
>>> a = A()  
>>> a.B  
100500  
>>> a  
<__main__.A object at 0x7fe3d0aa1400>  
>>> b = A()  
>>> b.B  
100500  
>>> b.B = 42  
>>> a.B  
42  
>>> b  
<__main__.A object at 0x7fe3d0aa1400>  
>>> a is b  
True  
>>>
```

---
---

Match-case

Формальное его название — «Структурное сопоставление шаблону». Синтаксис шаблонов вообще не такой, как в Python, всё благодаря PEG-парсеру вместо LL, который  не разделял контексты 

```python
>>> cmd = "help command"  
>>> cmd.split()  
['help', 'command']  
>>> if cmd.split() == ['help']  
 File "<python-input-40>", line 1  
   if cmd.split() == ['help']  
                             ^  
SyntaxError: expected ':'  
>>> if cmd.split() == ['help']:  
...     print("help")  
... elif cmd.split() == ['help', 'command']:  
...     print('smth more')  
...     # …  
...        
smth more  
>>>    
>>> match cpm.split():  
...     case ['help']:  
...         print('HELP')  
...     case ['help', 'command']:  
...         print('Command help')  
...     case _:  
...         print("UNKNOWN")  
...            
Traceback (most recent call last):  
 File "<python-input-43>", line 1, in <module>  
   match cpm.split():  
         ^^^  
NameError: name 'cpm' is not defined  
>>> match cmd.split():  
...     case ['help']:  
...         print('HELP')  
...     case ['help', 'command']:  
...         print('Command help')  
...     case _:  
...         print("UNKNOWN")  
...            
Command help  
>>> cmd = 'PAWSHFPA'  
>>> match cmd.split():  
...     case ['help']:  
...         print('HELP')  
...     case ['help', 'command']:  
...         print('Command help')  
...     case _:  
...         print("UNKNOWN")  
...            
UNKNOWN  
>>>
```

Связанные переменные:

```python
>>> cmd = 'help me!'  
... match cmd.split():  
...     case ['help']:  
...         print('HELP')  
...     case ['help', 'command']:  
...         print('Command help')  
...     case ['help', command]:  
...         print(f'help on {command}')  
...     case _:  
...         print("UNKNOWN")  
...            
help on me!  
>>> command  
'me!'  
>>>
```

```python
>>> cmd = 'help me please!'  
... match cmd.split():  
...     case ['help']:  
...         print('HELP')  
...     case ['help', 'command']:  
...         print('Command help')  
...     case ['help', command]:  
...         print(f'help on {command}')  
...     case _:  
...         print("UNKNOWN")  
...            
UNKNOWN  
>>> cmd = 'help me please!'  
... match cmd.split():  
...     case ['help']:  
...         print('HELP')  
...     case ['help', 'command']:  
...         print('Command help')  
...     case ['help', command]:  
...         print(f'help on {command}')  
...     case ['help', *cmds]:  
...         print('Hepl on', cmds)  
...     case _:  
...         print("UNKNOWN")  
...            
Hepl on ['me', 'please!']  
>>>
```

принцип отлова — до первого совпадения

Альтернативы — перегруженный оператор побитового ИЛИ для строк:

```python
>>> cmd = 'usage'  
... match cmd.split():  
...     case ['help']:  
...         print('HELP')  
...     case ['help', 'command']:  
...         print('Command help')  
...     case ['help', command]:  
...         print(f'help on {command}')  
...     case ['help', *cmds]:  
...         print('Hepl on', cmds)  
...     case _:  
...         print("UNKNOWN")  
...            
UNKNOWN  
>>> cmd = 'usage'  
... match cmd.split():  
...     case ['help' | 'usage']:  
...         print('HELP')  
...     case ['help', 'command']:  
...         print('Command help')  
...     case ['help', command]:  
...         print(f'help on {command}')  
...     case ['help', *cmds]:  
...         print('Hepl on', cmds)  
...     case _:  
...         print("UNKNOWN")  
...            
HELP  
>>>
```

И можно имя привязать:

```python
>>> cmd = 'usage'  
... match cmd.split():  
...     case ['help' | 'usage' as topic]:  
...         print(f'HELP = {topic}')  
...     case ['help', 'command']:  
...         print('Command help')  
...     case ['help', command]:  
...         print(f'help on {command}')  
...     case ['help', *cmds]:  
...         print('Hepl on', cmds)  
...     case _:  
...         print("UNKNOWN")  
...            
HELP = usage  
>>>
```

Можно добавить фильтры:

```python
>>> cmd = 'help go go'  
... match cmd.split():  
...     case ['help' | 'usage' as topic]:  
...         print(f'HELP = {topic}')  
...     case ['help', 'command']:  
...         print('Command help')  
...     case ['help', command]:  
...         print(f'help on {command}')  
...     case ['help', *cmds] if len(cmds) < 3:  
...         print('Hepl on', cmds)  
...     case _:  
...         print("UNKNOWN")  
...            
Hepl on ['go', 'go']  
>>> cmd = 'help go go go'  
... match cmd.split():  
...     case ['help' | 'usage' as topic]:  
...         print(f'HELP = {topic}')  
...     case ['help', 'command']:  
...         print('Command help')  
...     case ['help', command]:  
...         print(f'help on {command}')  
...     case ['help', *cmds] if len(cmds) < 3:  
...         print('Hepl on', cmds)  
...     case _:  
...         print("UNKNOWN")  
...            
UNKNOWN  
>>>
```

сопоставление, собственно, структур и типов

```python
>>> match v := eval(input()):  
...     case int(n):  
...         print(f'integer {n}')  
...     case float():  
...         print(f'Float {v}')  
...            
123  
integer 123  
>>> match v := eval(input()):  
...     case int(n):  
...         print(f'integer {n}')  
...     case float():  
...         print(f'Float {v}')  
...            
123.123  
Float 123.123  
>>> # это про структуру класса, его первое поле мы закрываем связанной переменной  
>>>
```

```python
>>> class C:  
...     A = 123  
...        
>>> c = C()  
>>> c.A = 100500  
>>>    
>>> match c:  
...     case C(A=100500):  
...         print('Y')  
...            
Y  
>>> c.A = 42  
>>> match c:  
...     case C(A=100500):  
...         print('Y')  
...            
>>>
```

Можно подвязываться как поимённо, так и позиционно

```python
>>> from collections import namedtuple  
... C = namedtuple("C", "a b")  
... for c in C(2, 3), C(1, 2), C(2, 1), C(42, 100500), C(-1, -1):  
...     match c:  
...         case C(2, 3):                           # Позиционное перечисление  
...             print(C, "with 2 and 3")  
...         case C(a=1, b=V) | C(a=V, b=1):         # Поимённое перечисление, одна переменная связана  
...             print(C, "with 1 and", V)  
...         case C(42):                             # Позиционное задание только одного поля  
...             print("Special", C)  
...         case C(A, b=B):                         # Одна переменная связана позиционно, другая — име\  
нем  
...             print("Any", C, "with", A, "and", B)  
...                
<class '__main__.C'> with 2 and 3  
<class '__main__.C'> with 1 and 2  
<class '__main__.C'> with 1 and 2  
Special <class '__main__.C'>  
Any <class '__main__.C'> with -1 and -1  
>>>
```

Можно заматчить словари, при этом будет притягиваться кусок словаря:

```python
>>> d = {1:2, 3:4, 5:6}  
... match d:  
...     case {3:4}:  
...         print("3:4")  
...            
3:4  
>>> d = {1:2, 3:4, 5:7}  
... match d:  
...     case {3:4, **tail}:  
...         print("3:4", tail)  
...            
3:4 {1: 2, 5: 7}  
>>>
```

Важно: переменные в шаблоне считаются свободными. Чтобы притянуть константу в match-case, надо её хранить отдельно и обращаться отдельно.

---
---

Аннотации

Зачем нам Duck Typing? Помогает писать короткий код быстро, использование функций, как алгоритмов, а не как преобразователей типов итд. _Неявная динамическая строгая типизация_ помогает делать код читаемым и маленьким. Но отсюда проблемы с RunTime-ошибками. Статический анализ никуда не пихнуть, пользователю не сообщить

Аннотация — это синтаксис питона, который позволяет сообщать подсказки аргументов и возвращаемых значений функций, а также полей классов

```python
>>> class C:  
...     A: int  
...     B: float = 1.2  
...     def __init__(self, a: int, b: float) -> None:  
...         self.A, self.B = a, b  
...     def sum(self) -> float:  
...         return self.A + self.B  
...            
>>> c = C('#WS', 'POI')  
>>> c.sum()  
'#WSPOI'  
>>>
```

```python
>>> import inspect  
>>> inspect.get_annotations(C)  
{'A': <class 'int'>, 'B': <class 'float'>}  
>>> ann = inspect.get_annotations(C)  
>>> ann['A']  
<class 'int'>  
>>> ann['B']  
<class 'float'>  
>>> ann = inspect.get_annotations(C.sum)  
>>> ann  
{'return': <class 'float'>}  
>>> inspect.get_annotations(C.__init__)  
{'a': <class 'int'>, 'b': <class 'float'>, 'return': None}  
```

При этом наличие аннотации не означает наличие объекта:

```python
>>> C.B  
1.2  
>>> C.A  
Traceback (most recent call last):  
 File "<python-input-87>", line 1, in <module>  
   C.A  
AttributeError: type object 'C' has no attribute 'A'  
>>>
```

Аннотациями может быть вообще любой питоновский объект:

```python
>> class C:  
...     a: "askfiha"  = 12  
...     b: 42 = 'QQ'  
...        
>>> inspect.get_annotations(C)  
{'a': 'askfiha', 'b': 42}  
>>>
```

