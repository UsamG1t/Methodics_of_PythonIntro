На деле мы очень много не потрогали, что могли бы

Начнём с конца — советов, что можно смотреть дальше, если Питон именно в процессе этих лекций стал понятным.

В процессе лекций мы изучали синтаксис (и мы знаем, что он не один в питоне), потрогали семантику. А вот далее — бесконечная пропасть практики

При работе с языком очень важно быть в курсе всех обновлений. Особенно для Питона — языка, который развивается очень быстро. В частности, в 3.14 питон (который на момент написания  — самый новый) добавили t-строки, обновление по аннотациям, дописали модули, н-р, поддержку zstd

Можно оставить пристальное изучение питона, если вы не будете явно программировать-программировать на нём. Но в продолжение стоит посмотреть примы разработки вообще, о них — следующий семестр.

Есть неплохие методики и подходы к программированию (ООП классический и неклассический итд)

Можно изучить статическую типизацию и инструменты в нём. Туда же — asyncio, на котором пишутся все асинхронные элементы.

Нельзя не упомянуть Data Science, ML, DL

---

Что хотелось бы посмотреть.

Первое это стили оформления кода. Питон, как хорошо читаемый язык, очень этого требует

Мы не посмотрели расширения, оформленные в виде модулей, но используемые на практике и приносящие удовольствие

Частично в след.семестре поговорим про то, какие инструменты разработки есть в самом питоне. 

В боевом программировании используется множество полезных модулей. Часть мы быстро посмотрели, далее  — всё в ваших руках

Про сторонние пакеты мы также поговорим в будущем

---

Про модули и пакеты мы вообще не говорили в курсе. Вот сейчас исправим это

import — это 

Нам, как пользователям, проще сказать, как это работает с нашей стороны

```python
>>> import sys  
>>> sys.path  
['', '/usr/lib/python313.zip', '/usr/lib/python3.13', '/usr/lib/python3.13/lib-dynload', '/home/papillo  
n_rouge/.local/lib/python3.13/site-packages', '/usr/lib/python3.13/site-packages']  
>>> # Есть зипархивы на уровне файловых систем  
>>> # Модули ищутся в этих каталогах или в файлах .pth где-то в них  
>>>    
>>> # Можно указать PYTHONPATH для поиска  
>>>
```

**Модуль** — это вообще _любой_ файл `.py`

```console
[user@userPC]$ cat > modd.py
var = 100500  
[user@userPC]$
```

```python
>>> import modd  
>>> modd.var  
100500  
>>>
```

Модули в большей степени пишут на C, и их тоже можно импортировать в питончик

```console
[user@userPC]$ ls /usr/lib64/python3.13/site-packages/zbar.so
/usr/lib64/python3.13/site-packages/zbar.so
[user@userPC]$
```

```python
>>> import zbar  
>>> dir(zbar)  
['BAR', 'BusyError', 'Config', 'Decoder', 'EnumItem', 'Exception', 'Image', 'ImageScanner', 'InternalEr  
ror', 'InvalidRequestError', 'LockingError', 'Modifier', 'Orient', 'Processor', 'SPACE', 'Scanner', 'Sy  
mbol', 'SymbolIter', 'SymbolSet', 'SystemError', 'UnsupportedError', 'WinAPIError', 'WindowClosed', 'X1  
1DisplayError', 'X11ProtocolError', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__  
spec__', 'increase_verbosity', 'set_verbosity', 'version']  
>>>
```

Пакеты можно писать в виде каталога

```console
[user@userPC]$ tree /usr/lib64/python3.13/site-packages/xcbgen
/usr/lib64/python3.13/site-packages/xcbgen  
├── align.py  
├── error.py  
├── expr.py  
├── __init__.py  
├── matcher.py  
├── __pycache__  
│   ├── align.cpython-313.opt-1.pyc  
│   ├── align.cpython-313.opt-2.pyc  
│   ├── align.cpython-313.pyc  
│   ├── error.cpython-313.opt-1.pyc  
│   ├── error.cpython-313.opt-2.pyc  
│   ├── error.cpython-313.pyc  
│   ├── expr.cpython-313.opt-1.pyc  
│   ├── expr.cpython-313.opt-2.pyc  
│   ├── expr.cpython-313.pyc  
│   ├── __init__.cpython-313.opt-1.pyc  
│   ├── __init__.cpython-313.opt-2.pyc  
│   ├── __init__.cpython-313.pyc  
│   ├── matcher.cpython-313.opt-1.pyc  
│   ├── matcher.cpython-313.opt-2.pyc  
│   ├── matcher.cpython-313.pyc  
│   ├── state.cpython-313.opt-1.pyc  
│   ├── state.cpython-313.opt-2.pyc  
│   ├── state.cpython-313.pyc  
│   ├── xtypes.cpython-313.opt-1.pyc  
│   ├── xtypes.cpython-313.opt-2.pyc  
│   └── xtypes.cpython-313.pyc  
├── state.py  
└── xtypes.py  
  
2 directories, 28 files
[user@userPC]$
```

Пакет состоит из `.py`-файлов и `__init__.py`. Указание этого Инита говорит о возможности импортирования пакета

Хотя в современном питоне можно импортировать директории и без инита, это нужно на случай, когда пакет разбит на множество блоков в разных директориях (например, при написании плагинов к уже существующим пакетам) (т.н. Сборники)

В пакетах могут быть другие пакеты

\*Пример относительного import из лекции

Повторный импорт — операция дешёвая, всё кешируется. Если вы,правда, потрогали исходники, надо руками удалять кеш, само не подтянется. 

---

Модуль — сам по себе программа, его импорт это буквально его исполнение. Чтобы отличать импорт модуля от запуска его как программы, можно писать всеми известное `if __name__ == '__main__'`

Чтобы пакет представлять как программу, надо написать ему тот самый файл `__main__.py`

---

```python
>>> import this  
The Zen of Python, by Tim Peters  
  
Beautiful is better than ugly.  
Explicit is better than implicit.  
Simple is better than complex.  
Complex is better than complicated.  
Flat is better than nested.  
Sparse is better than dense.  
Readability counts.  
Special cases aren't special enough to break the rules.  
Although practicality beats purity.  
Errors should never pass silently.  
Unless explicitly silenced.  
In the face of ambiguity, refuse the temptation to guess.  
There should be one-- and preferably only one --obvious way to do it.  
Although that way may not be obvious at first unless you're Dutch.  
Now is better than never.  
Although never is often better than *right* now.  
If the implementation is hard to explain, it's a bad idea.  
If the implementation is easy to explain, it may be a good idea.  
Namespaces are one honking great idea -- let's do more of those!  
>>>
```
